**rawmode概念，相对于canonical mode**
1. 无缓冲处理：每个字符一旦输入就立即传递给程序，不需等待换行符
2. 禁用特殊字符：
    - `Ctrl+C`不会中断程序而是作为普通字符传递
    - 退格键不会删除字符，只会产生对应的ASCII码(127)
3. 禁用回显：输入的字符不会自动显示在屏幕上
4. 无输入处理：禁用自动CR（回车）到NL（换行）转换等自动处理

**启用rawmode**
在函数`int enableRawMode(int fd)`实现
`tcgetattr(fd, &orig_termios)`读取规范模式的终端参数
然后在`raw`中修改，通过`tcsetattr(fd,TCSAFLUSH,&raw)`应用，完成设置
安全措施：`atexit(editorAtExit)`

**read()**
`ssize_t read(int __fd, void *__buf, size_t __nbytes)`
`Read NBYTES into BUF from FD. Return the number read,-1 for errors or 0 for EOF.`
典型的函数定义
读取n个数据存储到`* __buf`指定的地址处，并且返回 -1 / 0 / 正数

**文件描述符 fd**
/dev/pts/0其实是一个文件
`/dev 目录下都是硬件设备，想起了一切都是文件这个设计理念`

| STDIN_FILENO                   | STDOUT_FILENO                 |
| ------------------------------ | ----------------------------- |
| 指向输入缓冲区                        | 指向输出缓冲区                       |
| 读取用户输入/<br>处理输入流中的数据<br>read() | 向终端输出数据/<br>发送控制序列<br>write() |
|                                | 获取终端属性<br>ioctl()             |

```
           +---------------------------+
           |      终端设备(/dev/tty)    |
           |      (通常是/dev/pts/0)    |
           +-----------+---------------+
                       |
         +-------------+---------------+
         |                             |
+--------v-------+           +---------v------+
|  输入缓冲区     |           |  输出缓冲区    |
+----------------+           +----------------+
         ^                             ^
         |                             |
         |                             |
+--------+---------+       +-----------+------+
|  STDIN_FILENO (0)|       | STDOUT_FILENO (1)|
+------------------+       +------------------+
```